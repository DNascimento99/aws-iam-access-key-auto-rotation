import botocore
import boto3
import datetime
import os

# Inputs from Environment Variables

# Global Variables
sns_arn = os.environ["sns_arn"]

# Environment Variable: RotationPeriod
# The number of days after which a key should be rotated
rotationPeriod = int(os.environ['RotationPeriod'])

# Environment Variable: InactivePeriod
# The number of days after which to inactivate keys that had been rotated
# Note: This must be greater than RotationPeriod
oldKeyInactivationPeriod = int(os.environ['InactivePeriod'])

# Environment Variable: RetentionPeriod
# The number of days after which to delete keys that have been rotated and inactivated
# Note: This must be greater than InactivePeriod
oldKeyDeletionPeriod = int(os.environ['RetentionPeriod'])

# Pre-calculate the rotation and retention cutoff dates
rotationDate = (datetime.datetime.now() - datetime.timedelta(days=rotationPeriod)).date()
inactivationDate = (datetime.datetime.now() - datetime.timedelta(days=oldKeyInactivationPeriod)).date()
deletionDate = (datetime.datetime.now() - datetime.timedelta(days=oldKeyDeletionPeriod)).date()

# Format for lines in credentials.txt
akidLineFormat = 'aws_access_key_id = {}'
secretLineFormat = 'aws_secret_access_key = {}'

# Format for name of ASM secrets
secretNameFormat = 'User_{}_AccessKey'

# IAM Client
iam = boto3.client('iam')

# Secrets Manager Client
sm = boto3.client('secretsmanager')

# SNS Client
sns = boto3.client('sns')


# Main method for the lambda function
def lambda_handler(event, context):
    users = iam.list_users()
    response = {}

    for user in users['Users']:
        process_user(user, response, context)

    # Build a response for debugging - doesn't change actual work done, just gives output for testing in Lambda console
    # response = build_response(results)
    response['RotationDate'] = rotationDate.__str__()
    return response

def get_message(user_name, context):
    """Format SNS Message Function"""
    secret_name = secretNameFormat.format(user_name)
    message = f"A new AWS IAM Access Key pair was created. Please access your secret named {secret_name} to retrieve the new Access Keys and update your applications accordingly.\n\n"
    message += "UserName: " + str(user_name) + "\n"
    message += "Account: " + get_account_id() + "\n"
    message += "\n\n"
    message += "This notification was generated by the AWS Lambda Function. " + \
        context.invoked_function_arn
    return message

def send_message(message):
    """Send SNS Publish Function."""
    try:
        response = sns_client.publish(
            TopicArn=sns_arn,
            Message= message,
            Subject="New AWS IAM Access Key Pair Created."
        )
    except ClientError as error:
        print(error)

def get_account_id():
    """
    Gets the current account ID.

    :return The current account Id of the Lambda function.
    """
    try:
        account_id = sts_client.get_caller_identity().get("Account")
    except ClientError as error:
        print(error)

    return account_id

def process_user(user, response, context):
    """Rotate access keys for a user.

    Inactive keys will be deleted
    Users with no active access keys will not be processed
    Users with an access key older than the rotation date will have a new key created and stored in ASM, deleting the oldest key if necessary.
    Users with an active access key older than the inactivation date, and an active access key newer than the rotation date will have the oldest key inactivated.
    Users with an inactive access key older than the deletion period, and an active access key newer than the rotation date will have the oldest key deleted
    On a single run of this lambda, a key will only move from active to inactive or inactive to deleted.
    """

    user_name = user['UserName']
    response[user_name] = {}
    lak = iam.list_access_keys(UserName=user_name)

    num_keys = 0

    # Active Keys
    active_keys = []

    # Inactive Keys
    inactive_keys = []

    # Oldest Key
    oldest_key = None

    # Classify all access keys for the current user
    for akm in lak['AccessKeyMetadata']:
        num_keys += 1
        if oldest_key is None or oldest_key['CreateDate'] > akm['CreateDate']:
            oldest_key = akm
        if akm['Status'] == 'Active':
            active_keys.append(akm)
        else:
            inactive_keys.append(akm)

    num_active = len(active_keys)
    num_inactive = len(inactive_keys)

    if num_active == 2:
        classification_1 = classify_date(active_keys[0])
        classification_2 = classify_date(active_keys[1])

        # Two Active Keys
        if classification_1 == "New" or classification_2 == "New":
            # At least one key is new. Handle oldest one according to inactivation/deletion dates
            handle_oldest_key(user_name, response, oldest_key)
        else:
            # Both keys older than rotation date. Delete oldest and create new
            key_to_delete = oldest_key['AccessKeyId']
            iam.delete_access_key(UserName=user_name, AccessKeyId=key_to_delete)
            response[user_name]["Deleted Old Key"] = key_to_delete
            create_access_key(user, response, context)
            response[user_name]["Action"] = "Key rotated."
    elif num_active == 1 and num_inactive == 1:
        # One active and one inactive. Handle inactive key according to inactivation/deletion dates
        handle_oldest_key(user_name, response, inactive_keys[0])
    elif num_active == 1 and num_inactive == 0:
        # Single key that is active. Rotate if necessary.
        classification = classify_date(active_keys[0])
        if classification == "New":
            response[user_name]["Action"] = "No key rotation required."
        else:
            create_access_key(user, response, context)
            response[user_name]["Action"] = "Key rotated."
    elif num_active == 0 and num_inactive > 0:
        # If no active keys, delete all inactive keys
        response[user_name]["Deleted Inactive Keys"] = []
        for key_to_delete in inactive_keys:
            iam.delete_access_key(UserName=user_name, AccessKeyId=key_to_delete)
            response[user_name]["Deleted Inactive Keys"].append(key_to_delete)


def classify_date(akm):
    creation_date = akm['CreateDate'].date()
    if creation_date > rotationDate:
        return "New"
    if creation_date > inactivationDate:
        return "Rotate"
    if creation_date > deletionDate:
        return "Inactivate"
    return "Delete"


def handle_oldest_key(user_name, response, oldest_key):
    classification = classify_date(oldest_key)

    if classification == "Inactivate":
        key_to_inactivate = oldest_key['AccessKeyId']
        iam.update_access_key(UserName=user_name, AccessKeyId=key_to_inactivate, Status='Inactive')
        response[user_name]["Inactivated Old Key"] = key_to_inactivate
    elif classification == "Delete":
        key_to_delete = oldest_key['AccessKeyId']
        iam.delete_access_key(UserName=user_name, AccessKeyId=key_to_delete)
        response[user_name]["Deleted Old Key"] = key_to_delete


def create_access_key(user, response, context):
    user_name = user['UserName']
    secret_name = secretNameFormat.format(user_name)

    # Create new access key
    new_access_key = iam.create_access_key(UserName=user_name)
    response[user_name]["Created Access Key"] = new_access_key['AccessKey']['AccessKeyId']
    response[user_name]["ASM Secret Name"] = secret_name

    message = get_message(user_name, context)
    send_message(message)

    akid_line = akidLineFormat.format(new_access_key['AccessKey']['AccessKeyId'])
    secret_line = secretLineFormat.format(new_access_key['AccessKey']['SecretAccessKey'])
    cred_file_body = '{}\n{}'.format(akid_line, secret_line)

    # Create new secret, or store in existing
    create_secret = False
    try:
        # See if the secret we need already exists
        sm.describe_secret(SecretId=secret_name)
    except botocore.exceptions.ClientError as e:
        if e.response['Error']['Code'] == 'ResourceNotFoundException':
            create_secret = True
        else:
            raise e  # Go Bonk

    if create_secret:
        sm.create_secret(Name=secret_name, Description='Auto-created secret', SecretString=cred_file_body)
    else:
        sm.put_secret_value(SecretId=secret_name, SecretString=cred_file_body)
